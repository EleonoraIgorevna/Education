//Лекция 1
console.log("Кря");
console.log(a);
var a = 1;
console.log(a);
//Объявление переменных до ES5 был var - минусы- область видимости глобальная, переменная дсотупная после объявления и до
//В js есть понятие хостинга и оно распространяется на функции и var
//Хостинг это поднятие
//Но var ограничивается или глобалкой или внутри функции, если объявить var внутри функции, то она будет доступна только внутри нее
//Если вывести переменную var до ее объявление, то код не упадет, а просто определит переменную, как undefined
//У перемнных let и const область видимости внутри {} и при вызове до объявление будет ошибка - Cannot access before initialization
//const мы не можем переопределить
//var это объект window, let/const хранятся в отдельных скопах, в отдельных/изолированных областях видимости
// let/const позволяют аккуратно изолировать переменные
// в отличие от глобального объекта window, с let и const у нас работают сборщики мусора и прибираются и удаляет данные, которые не используются
//называем переменные в camelCase c маленькой буквы, но классы с Большой
//нельзя для названия переменных брать зарезервированные имена, можно называть начиная с _ или $
//dog string - для описания функция, для документирования кода
//js у нас динамически типизируемый язык и он не имеет статических типов, любой тип можно переопределить. если переменная хранило число, я могу спокойно перезаписать строку
//TODO комментарий для доработок
//в js есть два типа данных: примитивные и ссылочные
// примитивы- string, number, булевый тип данных, undefined, null
//в EC6 и выше вот такая ковычка ` является оператором шаблонной строки
//В EC5 было дохерища изменений и поэтому он так важен
//перенос строк \n
console.log("Кр\nя");
//Линтер работает фоном и следит за тем, как мы пишем код
//usestrict это нативная линтеризация
// \-экранирование
//infinity это number
let a = 10 / 0;
console.log(a, typeof a);

// Любое арифметическое (унарные тоже -a)действие пытается преобразовать операнды к числу
//10 * 'hi' = NaN (typeof NaN = number)
//10 * '3' = 30
//"3" унарный плюс принудительно сделает строку число +value
// или Number(a) - декларативный/явный способ
//Из числа в строку: value+``
//parseInt(a) =>3.14=>3
//число в 16 системе 2e3 это number
//Object это объект или массив или функция,
//Все в js является производной от объекта, экземпляры на основе класса Object
//use strict - ручной линтер
// движок v8 - интерпритатор
//Операторы
//Конкатенация (Если при + хотя бы один оператор строка, то преобразование будет в строку)
//"1"+"1"=>11
//"1"+1 => 11
// 1+"1"=>11
// при конкатенации все приводится к строке
//2.20 сравнение чисел и строк
// библиотека Math

//Лекция 2
//Оператор - команда, (унарный оператор и бинарный)
//if-else, else if
//switch - нельзя писать || , только строгие выражения, можно возвращать по дефолту null 
// тернарный оператор
// const b = ( a >7
//      ? "Yes"
//      ; "No")
//alert/prompt это интерфейс браузера
//DONT REPEAT YOURSELF - логика повторяется дважды
// В ООП потворение не допустимо
//function
//!!0 = false - двойное отрицание приводит к булевым значениям
// function Declaration имеет Хостинг. вызов функции через function
// function Expression - функциональное выражение const foo == function(){}v
// в js нет типа функции, функция это частный случай объекта
// вызывать arguments -выводить в консоль лог внутри функции, отобразит все аргументы, можно даже подавать больше
// Рекурсивная функция вызывается энное количество раз, пока не достигнет нужного результата
// Ее использование очень затратно, тратитится какой то кусочек памяти и стек заполняется заполнняется и вызывается call stack - стеку вызовов
// Рекурсивная функция вызываем саму себя и содержит повторяющуюся логику, которую нужно повторять энное количество раз
// Цикл приоритетнее рекурсии
// СОБЕСЕДОВАНИЯ РЕКУРСИЯ ФИБОНАЧИ или ФАКТОРИАЛ 
// confirm(хотите еще поиграть?)

//Лекция 3
// Каждое выполнение цикла это итерация
// do..while
// while
// for через break можно прервать цикл, а continue продолжает
// отрисовка товара через цикл
// можно создавать через new Array(5.6.7);
// свойство length доступно также на запись
// циклы не забивают стек, любую рекурсию заменяем циклом 
// Перебираем массив: for of (value), for in(index), foreach(index,value,array), map
// прототип массива - объект и поэтому к массиву можно применять методы объекта, например hasOwnProperty
// мутабельные методы - изменяют исходный массив
// не мутабельные методы - либо возвращают новый, либо не изменяют
// Методы массива
// Копирование массива, чтобы ссылки были разные - map
// Array.from(array) - возвращает копию массива (не глубокую), ссылка также копируется
// !!!!JSON.parse(JSON.stringify(array)); (глубокое копирование, изменяет ссылки)
// Задача отгадать быки и коровы 2 часа 10 минут


//Лекция 4
// Паттерн ООП - любую сущность описываем через объект
// литеральная запись {}
// декларативная запись new Object()
// Object.keys(myObject); //вернет массив ключей
// Итерируем объект через Symbol. iterator - для перебора обектов  
// Повторно посмотреть до 59 минуты
// Игра крестики и нолики
//